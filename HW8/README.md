# DFT & IDFT 手刻實作 (Python)

這個專案是一個純 Python 實作的 **離散傅立葉轉換 (DFT)** 與 **離散傅立葉逆轉換 (IDFT)**。

本程式不使用 `numpy.fft` 或 `scipy` 等現成訊號處理套件，而是依據數學定義，使用基礎的迴圈與複數運算庫 (`cmath`) 撰寫，旨在展示傅立葉轉換背後的數學邏輯與演算法實作細節。

## 1. 數學原理：從連續到離散

原始題目給出的是 **連續傅立葉轉換 (Continuous Fourier Transform)** 的積分形式，但在電腦數值計算中，我們必須處理離散的採樣點。因此，我們將數學模型進行了以下轉換：

### 1.1 符號對應關係

| 概念 | 連續 (Continuous) | 離散 (Discrete) |
| :--- | :--- | :--- |
| **運算** | 積分 $\int_{-\infty}^{\infty} dt$ | 加總 $\sum_{n=0}^{N-1}$ |
| **時間域變數** | $x$ (或 $t$) | $n$ (第 $n$ 個採樣點) |
| **頻率域變數** | $\omega$ | $k$ (第 $k$ 個頻率區間) |
| **基底函數** | $e^{-i\omega x}$ | $e^{-i \frac{2\pi}{N} kn}$ |
| **訊號長度** | 無限 ($\infty$) | 有限長度 ($N$) |

### 1.2 離散傅立葉轉換 (DFT) - 正轉換

將題目中的積分公式轉換為離散加總形式。對於長度為 $N$ 的序列 $x[n]$，其頻譜 $X[k]$ 定義為：

$$
X[k] = \sum_{n=0}^{N-1} x[n] \cdot e^{-i \frac{2\pi}{N} kn}
$$

* **$x[n]$**: 輸入的時間域訊號。
* **$X[k]$**: 輸出，代表第 $k$ 個頻率成分的複數強度（包含振幅與相位）。
* **$e^{-i \dots}$**: 歐拉公式 (Euler's formula) $e^{-i\theta} = \cos(\theta) - i\sin(\theta)$，在程式中由 `cmath.exp()` 處理。

### 1.3 離散傅立葉逆轉換 (IDFT) - 逆轉換

逆轉換將頻率域訊號還原回時間域。注意這裡需要進行 **正規化 (Normalization)**，即除以樣本數 $N$：

$$
x[n] = \frac{1}{N} \sum_{k=0}^{N-1} X[k] \cdot e^{i \frac{2\pi}{N} kn}
$$

* **指數符號**: 正轉換為負 ($e^{-i\dots}$)，逆轉換為正 ($e^{i\dots}$)。
* **$\frac{1}{N}$**: 在離散公式中，為了能量守恆或數值還原，通常在逆轉換階段除以 $N$（有些定義是在正轉換除，或兩邊各除 $\frac{1}{\sqrt{N}}$，本程式採用標準工程定義，於逆轉換時除以 $N$）。

---

## 2. 程式實作邏輯

程式碼結構直接對應上述數學公式：

### 2.1 複雜度分析
由於我們直接使用「雙重迴圈」來計算每一個 $X[k]$，演算法的時間複雜度為：
* **$O(N^2)$**
* 這與快速傅立葉轉換 (FFT) 的 $O(N \log N)$ 相比效率較低，但對於理解原理是最直觀的方式。

### 2.2 核心程式碼片段解釋

```python
# 正轉換 (DFT)
for k in range(N):           # 對每一個頻率 k
    sum_val = 0
    for n in range(N):       # 遍歷所有時間點 n 進行積分(加總)
        # 旋轉因子 (Twiddle Factor)
        angle = -2 * math.pi * k * n / N
        sum_val += x[n] * cmath.exp(1j * angle)
    X.append(sum_val)
